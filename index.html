<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Hybrid Transformations</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 50%, #16213e 100%);
            color: #e0e6ed;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            overflow: hidden;
        }
        
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: linear-gradient(145deg, rgba(15,15,35,0.95), rgba(26,26,46,0.9));
            backdrop-filter: blur(20px);
            border: 1px solid rgba(100, 150, 255, 0.2);
            padding: 20px;
            border-radius: 16px;
            max-width: 360px;
            max-height: 90vh;
            overflow-y: auto;
            z-index: 1000;
            box-shadow: 0 20px 40px rgba(0,0,0,0.4), 0 0 0 1px rgba(255,255,255,0.05);
        }
        
        .control-group {
            margin-bottom: 16px;
            padding: 16px;
            border: 1px solid rgba(100, 150, 255, 0.15);
            border-radius: 12px;
            background: linear-gradient(145deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }
        
        .control-group:hover {
            border-color: rgba(100, 150, 255, 0.3);
            background: linear-gradient(145deg, rgba(255,255,255,0.05), rgba(255,255,255,0.02));
            transform: translateY(-1px);
        }
        
        .control-group h4 {
            margin: 0 0 12px 0;
            color: #64b5f6;
            font-weight: 600;
            text-transform: uppercase;
            font-size: 12px;
            letter-spacing: 0.5px;
        }
        
        button {
            background: linear-gradient(135deg, #42a5f5 0%, #1e88e5 100%);
            color: white;
            border: none;
            padding: 10px 16px;
            margin: 3px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.2s ease;
            box-shadow: 0 4px 12px rgba(66, 165, 245, 0.3);
        }
        
        button:hover {
            background: linear-gradient(135deg, #1e88e5 0%, #1565c0 100%);
            transform: translateY(-1px);
            box-shadow: 0 6px 20px rgba(66, 165, 245, 0.4);
        }
        
        button:active {
            transform: translateY(0);
            box-shadow: 0 2px 8px rgba(66, 165, 245, 0.3);
        }
        
        input, select {
            background: rgba(15,15,35,0.8);
            color: #e0e6ed;
            border: 1px solid rgba(100, 150, 255, 0.2);
            padding: 6px 8px;
            margin: 2px;
            border-radius: 6px;
            width: 60px;
            font-size: 12px;
            transition: all 0.2s ease;
        }
        
        input:focus, select:focus {
            outline: none;
            border-color: #64b5f6;
            box-shadow: 0 0 0 2px rgba(100, 181, 246, 0.2);
        }
        
        label {
            font-size: 12px;
            margin-right: 6px;
            color: #b3c5d1;
            font-weight: 500;
        }
        
        #matrixDisplay {
            background: linear-gradient(135deg, rgba(15,15,35,0.9), rgba(26,26,46,0.8));
            border: 1px solid rgba(100, 150, 255, 0.2);
            padding: 12px;
            border-radius: 8px;
            font-family: 'Fira Code', 'Monaco', 'Cascadia Code', monospace;
            font-size: 10px;
            white-space: pre;
            max-height: 200px;
            overflow: auto;
            color: #81c784;
            line-height: 1.4;
        }
        
        #objectSelect {
            width: 130px;
            background: linear-gradient(135deg, rgba(15,15,35,0.9), rgba(26,26,46,0.8));
        }
        
        .axis-controls {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 8px 0;
            padding: 8px;
            background: rgba(255,255,255,0.02);
            border-radius: 6px;
            border: 1px solid rgba(100, 150, 255, 0.1);
        }
        
        #info {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: linear-gradient(145deg, rgba(15,15,35,0.95), rgba(26,26,46,0.9));
            backdrop-filter: blur(20px);
            border: 1px solid rgba(100, 150, 255, 0.2);
            padding: 16px;
            border-radius: 12px;
            font-size: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }
        
        /* Scrollbar styling */
        #controls::-webkit-scrollbar {
            width: 6px;
        }
        
        #controls::-webkit-scrollbar-track {
            background: rgba(255,255,255,0.05);
            border-radius: 3px;
        }
        
        #controls::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, #42a5f5, #1e88e5);
            border-radius: 3px;
        }
        
        #controls::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(135deg, #1e88e5, #1565c0);
        }
        
        /* Special button styles */
        button[onclick*="Hybrid"] {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%);
            box-shadow: 0 4px 12px rgba(255, 107, 107, 0.3);
        }
        
        button[onclick*="Hybrid"]:hover {
            background: linear-gradient(135deg, #ee5a52 0%, #d63447 100%);
            box-shadow: 0 6px 20px rgba(255, 107, 107, 0.4);
        }
        
        button[onclick*="Reset"] {
            background: linear-gradient(135deg, #ffa726 0%, #fb8c00 100%);
            box-shadow: 0 4px 12px rgba(255, 167, 38, 0.3);
        }
        
        button[onclick*="Reset"]:hover {
            background: linear-gradient(135deg, #fb8c00 0%, #ef6c00 100%);
            box-shadow: 0 6px 20px rgba(255, 167, 38, 0.4);
        }
    </style>
</head>
<body>
    <div id="controls">
        <div class="control-group">
            <h4>Object Selection</h4>
            <select id="objectSelect">
                <option value="cube">Cube</option>
                <option value="sphere">Sphere</option>
                <option value="cylinder">Cylinder</option>
                <option value="cone">Cone</option>
                <option value="torus">Torus</option>
                <option value="pyramid">Pyramid</option>
            </select>
            <button onclick="createObject()">Create Object</button>
        </div>

        <div class="control-group">
            <h4>Translation</h4>
            <div class="axis-controls">
                <label>X:</label><input type="number" id="transX" value="50" step="10">
                <label>Y:</label><input type="number" id="transY" value="0" step="10">
                <label>Z:</label><input type="number" id="transZ" value="0" step="10">
            </div>
            <button onclick="applyTransformation('translate')">Translate</button>
        </div>

        <div class="control-group">
            <h4>Scaling</h4>
            <div class="axis-controls">
                <label>X:</label><input type="number" id="scaleX" value="1.5" step="0.1">
                <label>Y:</label><input type="number" id="scaleY" value="1.5" step="0.1">
                <label>Z:</label><input type="number" id="scaleZ" value="1.5" step="0.1">
            </div>
            <button onclick="applyTransformation('scale')">Scale</button>
        </div>

        <div class="control-group">
            <h4>Rotation (degrees)</h4>
            <div class="axis-controls">
                <label>X:</label><input type="number" id="rotX" value="45" step="15">
                <label>Y:</label><input type="number" id="rotY" value="0" step="15">
                <label>Z:</label><input type="number" id="rotZ" value="0" step="15">
            </div>
            <button onclick="applyTransformation('rotate')">Rotate</button>
        </div>

        <div class="control-group">
            <h4>Reflection</h4>
            <select id="reflectPlane">
                <option value="x">YZ Plane (X=0)</option>
                <option value="y">XZ Plane (Y=0)</option>
                <option value="z">XY Plane (Z=0)</option>
                <option value="xy">XY Plane</option>
                <option value="xz">XZ Plane</option>
                <option value="yz">YZ Plane</option>
            </select>
            <button onclick="applyTransformation('reflect')">Reflect</button>
        </div>

        <div class="control-group">
            <h4>Shearing</h4>
            <div class="axis-controls">
                <label>Sxy:</label><input type="number" id="shearXY" value="0.3" step="0.1">
                <label>Sxz:</label><input type="number" id="shearXZ" value="0" step="0.1">
            </div>
            <div class="axis-controls">
                <label>Syx:</label><input type="number" id="shearYX" value="0" step="0.1">
                <label>Syz:</label><input type="number" id="shearYZ" value="0" step="0.1">
            </div>
            <div class="axis-controls">
                <label>Szx:</label><input type="number" id="shearZX" value="0" step="0.1">
                <label>Szy:</label><input type="number" id="shearZY" value="0" step="0.1">
            </div>
            <button onclick="applyTransformation('shear')">Shear</button>
        </div>

        <div class="control-group">
            <h4>Hybrid Transformation</h4>
            <button onclick="applyHybridTransformation()">Apply All Transformations</button>
        </div>

        <div class="control-group">
            <h4>Controls</h4>
            <button onclick="saveState()">Save State</button>
            <button onclick="undo()">Undo</button>
            <button onclick="redo()">Redo</button>
            <button onclick="resetObject()">Reset</button>
        </div>

        <div class="control-group">
            <h4>Current Transformation Matrix</h4>
            <div id="matrixDisplay"></div>
        </div>
    </div>

    <div id="info">
        <strong>Controls:</strong><br>
        Mouse: Orbit camera<br>
        Wheel: Zoom<br>
        Right click: Pan
    </div>

    <script type="module">
        import * as THREE from 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.module.min.js';

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0f0f23);
        scene.fog = new THREE.Fog(0x0f0f23, 200, 1000);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(200, 150, 200);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        document.body.appendChild(renderer.domElement);

        // Enhanced lighting
        const ambientLight = new THREE.AmbientLight(0x4169e1, 0.3);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0x64b5f6, 1.2);
        directionalLight.position.set(100, 100, 50);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);

        const pointLight = new THREE.PointLight(0xff6b9d, 0.8, 300);
        pointLight.position.set(-100, 50, 100);
        scene.add(pointLight);

        // Enhanced grid and axes
        const gridHelper = new THREE.GridHelper(400, 20, 0x64b5f6, 0x3949ab);
        gridHelper.material.opacity = 0.4;
        gridHelper.material.transparent = true;
        scene.add(gridHelper);

        const axesHelper = new THREE.AxesHelper(150);
        scene.add(axesHelper);

        // Camera controls (simplified orbit controls)
        let mouseDown = false;
        let mouseX = 0;
        let mouseY = 0;
        let targetX = 0;
        let targetY = 0;

        // Variables
        let currentObject = null;
        let originalGeometry = null;
        let transformationHistory = [];
        let redoHistory = [];
        let currentMatrix = new THREE.Matrix4();

        // Mouse controls
        renderer.domElement.addEventListener('mousedown', onMouseDown);
        renderer.domElement.addEventListener('mousemove', onMouseMove);
        renderer.domElement.addEventListener('mouseup', onMouseUp);
        renderer.domElement.addEventListener('wheel', onWheel);

        function onMouseDown(event) {
            mouseDown = true;
            mouseX = event.clientX;
            mouseY = event.clientY;
        }

        function onMouseMove(event) {
            if (!mouseDown) return;
            
            const deltaX = event.clientX - mouseX;
            const deltaY = event.clientY - mouseY;
            
            targetX += deltaX * 0.01;
            targetY += deltaY * 0.01;
            
            mouseX = event.clientX;
            mouseY = event.clientY;
        }

        function onMouseUp() {
            mouseDown = false;
        }

        function onWheel(event) {
            camera.position.multiplyScalar(event.deltaY > 0 ? 1.1 : 0.9);
        }

        // Create different 3D objects
        function createObject() {
            if (currentObject) {
                scene.remove(currentObject);
                currentObject.geometry.dispose();
                currentObject.material.dispose();
            }

            const objectType = document.getElementById('objectSelect').value;
            let geometry;

            switch (objectType) {
                case 'cube':
                    geometry = new THREE.BoxGeometry(50, 50, 50);
                    break;
                case 'sphere':
                    geometry = new THREE.SphereGeometry(30, 32, 16);
                    break;
                case 'cylinder':
                    geometry = new THREE.CylinderGeometry(25, 25, 50, 32);
                    break;
                case 'cone':
                    geometry = new THREE.ConeGeometry(25, 50, 32);
                    break;
                case 'torus':
                    geometry = new THREE.TorusGeometry(30, 10, 16, 100);
                    break;
                case 'pyramid':
                    geometry = new THREE.ConeGeometry(30, 50, 4);
                    break;
                default:
                    geometry = new THREE.BoxGeometry(50, 50, 50);
            }

            const materials = [
                new THREE.MeshPhysicalMaterial({ 
                    color: 0x64b5f6,
                    metalness: 0.3,
                    roughness: 0.4,
                    transparent: true,
                    opacity: 0.9,
                    envMapIntensity: 1.0
                }),
                new THREE.MeshPhysicalMaterial({ 
                    color: 0xff6b9d,
                    metalness: 0.2,
                    roughness: 0.3,
                    transparent: true,
                    opacity: 0.9,
                    envMapIntensity: 1.0
                }),
                new THREE.MeshPhysicalMaterial({ 
                    color: 0x81c784,
                    metalness: 0.4,
                    roughness: 0.2,
                    transparent: true,
                    opacity: 0.9,
                    envMapIntensity: 1.0
                }),
                new THREE.MeshPhysicalMaterial({ 
                    color: 0xffa726,
                    metalness: 0.1,
                    roughness: 0.5,
                    transparent: true,
                    opacity: 0.9,
                    envMapIntensity: 1.0
                }),
                new THREE.MeshPhysicalMaterial({ 
                    color: 0xba68c8,
                    metalness: 0.6,
                    roughness: 0.1,
                    transparent: true,
                    opacity: 0.9,
                    envMapIntensity: 1.0
                }),
                new THREE.MeshPhysicalMaterial({ 
                    color: 0xff5722,
                    metalness: 0.3,
                    roughness: 0.3,
                    transparent: true,
                    opacity: 0.9,
                    envMapIntensity: 1.0
                })
            ];

            const materialIndex = Math.floor(Math.random() * materials.length);
            const material = materials[materialIndex];

            currentObject = new THREE.Mesh(geometry, material);
            currentObject.castShadow = true;
            currentObject.receiveShadow = true;
            
            scene.add(currentObject);
            
            // Store original geometry for reset
            originalGeometry = geometry.clone();
            
            // Reset transformation matrix
            currentMatrix.identity();
            transformationHistory = [];
            redoHistory = [];
            
            updateMatrixDisplay();
        }

        // Create transformation matrices using homogeneous coordinates
        function createTranslationMatrix(tx, ty, tz) {
            return new THREE.Matrix4().set(
                1, 0, 0, tx,
                0, 1, 0, ty,
                0, 0, 1, tz,
                0, 0, 0, 1
            );
        }

        function createScaleMatrix(sx, sy, sz) {
            return new THREE.Matrix4().set(
                sx, 0, 0, 0,
                0, sy, 0, 0,
                0, 0, sz, 0,
                0, 0, 0, 1
            );
        }

        function createRotationMatrixX(angle) {
            const c = Math.cos(angle);
            const s = Math.sin(angle);
            return new THREE.Matrix4().set(
                1, 0, 0, 0,
                0, c, -s, 0,
                0, s, c, 0,
                0, 0, 0, 1
            );
        }

        function createRotationMatrixY(angle) {
            const c = Math.cos(angle);
            const s = Math.sin(angle);
            return new THREE.Matrix4().set(
                c, 0, s, 0,
                0, 1, 0, 0,
                -s, 0, c, 0,
                0, 0, 0, 1
            );
        }

        function createRotationMatrixZ(angle) {
            const c = Math.cos(angle);
            const s = Math.sin(angle);
            return new THREE.Matrix4().set(
                c, -s, 0, 0,
                s, c, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            );
        }

        function createReflectionMatrix(plane) {
            switch (plane) {
                case 'x': // YZ plane (reflect across X)
                    return new THREE.Matrix4().set(-1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1);
                case 'y': // XZ plane (reflect across Y)
                    return new THREE.Matrix4().set(1,0,0,0, 0,-1,0,0, 0,0,1,0, 0,0,0,1);
                case 'z': // XY plane (reflect across Z)
                    return new THREE.Matrix4().set(1,0,0,0, 0,1,0,0, 0,0,-1,0, 0,0,0,1);
                case 'xy': // XY plane
                    return new THREE.Matrix4().set(1,0,0,0, 0,1,0,0, 0,0,-1,0, 0,0,0,1);
                case 'xz': // XZ plane
                    return new THREE.Matrix4().set(1,0,0,0, 0,-1,0,0, 0,0,1,0, 0,0,0,1);
                case 'yz': // YZ plane
                    return new THREE.Matrix4().set(-1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1);
                default:
                    return new THREE.Matrix4().identity();
            }
        }

        function createShearMatrix(sxy, sxz, syx, syz, szx, szy) {
            return new THREE.Matrix4().set(
                1, sxy, sxz, 0,
                syx, 1, syz, 0,
                szx, szy, 1, 0,
                0, 0, 0, 1
            );
        }

        // Apply individual transformations
        function applyTransformation(type) {
            if (!currentObject) {
                alert('Please create an object first!');
                return;
            }

            saveState();
            let matrix;

            switch (type) {
                case 'translate':
                    const tx = parseFloat(document.getElementById('transX').value);
                    const ty = parseFloat(document.getElementById('transY').value);
                    const tz = parseFloat(document.getElementById('transZ').value);
                    matrix = createTranslationMatrix(tx, ty, tz);
                    break;

                case 'scale':
                    const sx = parseFloat(document.getElementById('scaleX').value);
                    const sy = parseFloat(document.getElementById('scaleY').value);
                    const sz = parseFloat(document.getElementById('scaleZ').value);
                    matrix = createScaleMatrix(sx, sy, sz);
                    break;

                case 'rotate':
                    const rx = parseFloat(document.getElementById('rotX').value) * Math.PI / 180;
                    const ry = parseFloat(document.getElementById('rotY').value) * Math.PI / 180;
                    const rz = parseFloat(document.getElementById('rotZ').value) * Math.PI / 180;
                    
                    const matrixX = createRotationMatrixX(rx);
                    const matrixY = createRotationMatrixY(ry);
                    const matrixZ = createRotationMatrixZ(rz);
                    
                    matrix = new THREE.Matrix4()
                        .multiplyMatrices(matrixZ, matrixY)
                        .multiply(matrixX);
                    break;

                case 'reflect':
                    const plane = document.getElementById('reflectPlane').value;
                    matrix = createReflectionMatrix(plane);
                    break;

                case 'shear':
                    const sxy = parseFloat(document.getElementById('shearXY').value);
                    const sxz = parseFloat(document.getElementById('shearXZ').value);
                    const syx = parseFloat(document.getElementById('shearYX').value);
                    const syz = parseFloat(document.getElementById('shearYZ').value);
                    const szx = parseFloat(document.getElementById('shearZX').value);
                    const szy = parseFloat(document.getElementById('shearZY').value);
                    matrix = createShearMatrix(sxy, sxz, syx, syz, szx, szy);
                    break;
            }

            if (matrix) {
                currentObject.applyMatrix4(matrix);
                currentMatrix.multiplyMatrices(matrix, currentMatrix);
                updateMatrixDisplay();
            }
        }

        // Apply hybrid transformation (all transformations combined)
        function applyHybridTransformation() {
            if (!currentObject) {
                alert('Please create an object first!');
                return;
            }

            saveState();

            // Create all transformation matrices
            const tx = parseFloat(document.getElementById('transX').value);
            const ty = parseFloat(document.getElementById('transY').value);
            const tz = parseFloat(document.getElementById('transZ').value);
            const translationMatrix = createTranslationMatrix(tx, ty, tz);

            const sx = parseFloat(document.getElementById('scaleX').value);
            const sy = parseFloat(document.getElementById('scaleY').value);
            const sz = parseFloat(document.getElementById('scaleZ').value);
            const scaleMatrix = createScaleMatrix(sx, sy, sz);

            const rx = parseFloat(document.getElementById('rotX').value) * Math.PI / 180;
            const ry = parseFloat(document.getElementById('rotY').value) * Math.PI / 180;
            const rz = parseFloat(document.getElementById('rotZ').value) * Math.PI / 180;
            
            const rotationMatrixX = createRotationMatrixX(rx);
            const rotationMatrixY = createRotationMatrixY(ry);
            const rotationMatrixZ = createRotationMatrixZ(rz);
            const rotationMatrix = new THREE.Matrix4()
                .multiplyMatrices(rotationMatrixZ, rotationMatrixY)
                .multiply(rotationMatrixX);

            const plane = document.getElementById('reflectPlane').value;
            const reflectionMatrix = createReflectionMatrix(plane);

            const sxy = parseFloat(document.getElementById('shearXY').value);
            const sxz = parseFloat(document.getElementById('shearXZ').value);
            const syx = parseFloat(document.getElementById('shearYX').value);
            const syz = parseFloat(document.getElementById('shearYZ').value);
            const szx = parseFloat(document.getElementById('shearZX').value);
            const szy = parseFloat(document.getElementById('shearZY').value);
            const shearMatrix = createShearMatrix(sxy, sxz, syx, syz, szx, szy);

            // Combine all transformations: T * R * S * Sh * Rf
            const hybridMatrix = new THREE.Matrix4()
                .multiplyMatrices(translationMatrix, rotationMatrix)
                .multiply(scaleMatrix)
                .multiply(shearMatrix)
                .multiply(reflectionMatrix);

            currentObject.applyMatrix4(hybridMatrix);
            currentMatrix.multiplyMatrices(hybridMatrix, currentMatrix);
            updateMatrixDisplay();
        }

        // History management
        function saveState() {
            if (currentObject) {
                transformationHistory.push({
                    matrix: currentObject.matrix.clone(),
                    currentMatrix: currentMatrix.clone()
                });
                redoHistory = [];
            }
        }

        function undo() {
            if (currentObject && transformationHistory.length > 0) {
                redoHistory.push({
                    matrix: currentObject.matrix.clone(),
                    currentMatrix: currentMatrix.clone()
                });
                
                const lastState = transformationHistory.pop();
                currentObject.matrix.copy(lastState.matrix);
                currentMatrix.copy(lastState.currentMatrix);
                currentObject.matrix.decompose(currentObject.position, currentObject.quaternion, currentObject.scale);
                updateMatrixDisplay();
            }
        }

        function redo() {
            if (currentObject && redoHistory.length > 0) {
                transformationHistory.push({
                    matrix: currentObject.matrix.clone(),
                    currentMatrix: currentMatrix.clone()
                });
                
                const nextState = redoHistory.pop();
                currentObject.matrix.copy(nextState.matrix);
                currentMatrix.copy(nextState.currentMatrix);
                currentObject.matrix.decompose(currentObject.position, currentObject.quaternion, currentObject.scale);
                updateMatrixDisplay();
            }
        }

        function resetObject() {
            if (currentObject && originalGeometry) {
                currentObject.position.set(0, 0, 0);
                currentObject.rotation.set(0, 0, 0);
                currentObject.scale.set(1, 1, 1);
                currentObject.matrix.identity();
                currentMatrix.identity();
                transformationHistory = [];
                redoHistory = [];
                updateMatrixDisplay();
            }
        }

        // Update matrix display
        function updateMatrixDisplay() {
            if (currentObject) {
                const m = currentObject.matrix.elements;
                let matrixStr = "Transformation Matrix (4x4):\n";
                for (let i = 0; i < 4; i++) {
                    const row = [];
                    for (let j = 0; j < 4; j++) {
                        row.push(m[j * 4 + i].toFixed(3));
                    }
                    matrixStr += row.join("\t") + "\n";
                }
                document.getElementById('matrixDisplay').textContent = matrixStr;
            }
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Smooth camera rotation
            camera.position.x = Math.cos(targetX) * Math.cos(targetY) * 200;
            camera.position.y = Math.sin(targetY) * 200;
            camera.position.z = Math.sin(targetX) * Math.cos(targetY) * 200;
            camera.lookAt(scene.position);
            
            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Expose functions to global scope
        window.createObject = createObject;
        window.applyTransformation = applyTransformation;
        window.applyHybridTransformation = applyHybridTransformation;
        window.saveState = saveState;
        window.undo = undo;
        window.redo = redo;
        window.resetObject = resetObject;

        // Initialize with a cube
        createObject();
        animate();
    </script>
</body>
</html>