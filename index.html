<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Hybrid Transformation with Custom Vertices</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
<div id="controls">
  <label for="verticesInput">Enter vertices (x,y,z) space-separated:</label><br>
  <input type="text" id="verticesInput" placeholder="-1,-1,-1 1,-1,-1 1,1,-1 -1,1,-1 -1,-1,1 1,-1,1 1,1,1 -1,1,1" size="50">
  <button onclick="createCustomMesh()">Draw Mesh</button>
  <br><br>

  <button onclick="saveState(); applyTranslation()">Translate</button>
  <button onclick="saveState(); applyScaling()">Scale</button>
  <button onclick="saveState(); applyRotationX()">Rotate X</button>
  <button onclick="saveState(); applyRotationY()">Rotate Y</button>
  <button onclick="saveState(); applyRotationZ()">Rotate Z</button>

  <select id="reflectAxis">
    <option value="xy">Reflect XY-plane</option>
    <option value="yz">Reflect YZ-plane</option>
    <option value="xz">Reflect XZ-plane</option>
  </select>
  <button onclick="saveState(); applyReflection()">Reflect</button>

  <label for="shearXY">Shear XY:</label>
  <input type="number" id="shearXY" value="0.5" step="0.1" style="width:50px">
  <label for="shearXZ">Shear XZ:</label>
  <input type="number" id="shearXZ" value="0.5" step="0.1" style="width:50px">
  <button onclick="saveState(); applyShearing()">Shear</button>

  <button onclick="undo()">Undo</button>
  <button onclick="redo()">Redo</button>
  <button onclick="resetMesh()">Reset</button>

  <pre id="matrixDisplay"></pre>
</div>

<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js';
import { ConvexGeometry } from 'https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/geometries/ConvexGeometry.js';

// Scene setup
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x708090); // Slate color


const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(5,5,5);
camera.lookAt(0,0,0);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Grid and axes
const grid = new THREE.GridHelper(20,20,0x888888,0xcccccc);
scene.add(grid);
const axes = new THREE.AxesHelper(5);
scene.add(axes);

let mesh = null;
let originalMatrix = null;
let history = [];
let redoHistory = [];

// Animation loop
function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}
animate();

// Create custom mesh using ConvexGeometry
function createCustomMesh() {
  if(mesh){
    scene.remove(mesh);
    mesh.geometry.dispose();
    mesh.material.dispose();
  }
  history = [];
  redoHistory = [];

  const input = document.getElementById("verticesInput").value.trim();
  if(!input) return alert("Enter vertices in x,y,z format space-separated");

  const points = input.split(" ").map(p => p.split(",").map(Number));
  if(points.length < 4) return alert("At least 4 vertices required for 3D mesh");

  const vectors = points.map(p => new THREE.Vector3(p[0], p[1], p[2]));

  const geometry = new ConvexGeometry(vectors);

  const material = new THREE.MeshNormalMaterial({wireframe:false, side:THREE.DoubleSide});
  mesh = new THREE.Mesh(geometry, material);
  mesh.matrixAutoUpdate = false;
  mesh.updateMatrix();
  originalMatrix = mesh.matrix.clone();

  scene.add(mesh);
  updateMatrixDisplay();
}

// Transformations
function saveState() {
  if(mesh) {
    history.push(mesh.matrix.clone());
    redoHistory = [];
  }
}

function undo() {
  if(mesh && history.length>0){
    redoHistory.push(mesh.matrix.clone());
    const last = history.pop();
    mesh.matrix.copy(last);
    mesh.matrix.decompose(mesh.position, mesh.quaternion, mesh.scale);
    updateMatrixDisplay();
  }
}

function redo() {
  if(mesh && redoHistory.length>0){
    history.push(mesh.matrix.clone());
    const next = redoHistory.pop();
    mesh.matrix.copy(next);
    mesh.matrix.decompose(mesh.position, mesh.quaternion, mesh.scale);
    updateMatrixDisplay();
  }
}

function applyTranslation() {
  if(!mesh) return;
  const m = new THREE.Matrix4();
  m.set(
    1,0,0,1,
    0,1,0,1,
    0,0,1,1,
    0,0,0,1
  );
  mesh.applyMatrix4(m);
  updateMatrixDisplay();
}

function applyScaling() {
  if(!mesh) return;
  const m = new THREE.Matrix4();
  m.set(
    1.5,0,0,0,
    0,1.5,0,0,
    0,0,1.5,0,
    0,0,0,1
  );
  mesh.applyMatrix4(m);
  updateMatrixDisplay();
}

function applyRotationX() {
  if(!mesh) return;
  const angle = Math.PI/4;
  const cos = Math.cos(angle), sin=Math.sin(angle);
  const m = new THREE.Matrix4().set(
    1,0,0,0,
    0,cos,-sin,0,
    0,sin,cos,0,
    0,0,0,1
  );
  mesh.applyMatrix4(m);
  updateMatrixDisplay();
}

function applyRotationY() {
  if(!mesh) return;
  const angle = Math.PI/4;
  const cos = Math.cos(angle), sin=Math.sin(angle);
  const m = new THREE.Matrix4().set(
    cos,0,sin,0,
    0,1,0,0,
    -sin,0,cos,0,
    0,0,0,1
  );
  mesh.applyMatrix4(m);
  updateMatrixDisplay();
}

function applyRotationZ() {
  if(!mesh) return;
  const angle = Math.PI/4;
  const cos = Math.cos(angle), sin=Math.sin(angle);
  const m = new THREE.Matrix4().set(
    cos,-sin,0,0,
    sin,cos,0,0,
    0,0,1,0,
    0,0,0,1
  );
  mesh.applyMatrix4(m);
  updateMatrixDisplay();
}

function applyReflection() {
  if(!mesh) return;
  const axis = document.getElementById("reflectAxis").value;
  const m = new THREE.Matrix4();
  if(axis==="xy") m.set(1,0,0,0, 0,1,0,0, 0,0,-1,0, 0,0,0,1);
  else if(axis==="yz") m.set(-1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1);
  else if(axis==="xz") m.set(1,0,0,0, 0,-1,0,0, 0,0,1,0, 0,0,0,1);
  mesh.applyMatrix4(m);
  updateMatrixDisplay();
}

function applyShearing() {
  if(!mesh) return;
  const sx = parseFloat(document.getElementById("shearXY").value);
  const sz = parseFloat(document.getElementById("shearXZ").value);
  const m = new THREE.Matrix4();
  m.set(
    1,sx,sz,0,
    0,1,0,0,
    0,0,1,0,
    0,0,0,1
  );
  mesh.applyMatrix4(m);
  updateMatrixDisplay();
}

function resetMesh() {
  if(!mesh) return;
  mesh.matrix.copy(originalMatrix);
  mesh.matrix.decompose(mesh.position, mesh.quaternion, mesh.scale);
  history = [];
  redoHistory = [];
  updateMatrixDisplay();
}

// Matrix display
function updateMatrixDisplay() {
  if(!mesh) return;
  const m = mesh.matrix.elements;
  let str = "";
  for(let i=0;i<4;i++){
    str += m.slice(i*4,i*4+4).map(n=>n.toFixed(2)).join("\t")+"\n";
  }
  document.getElementById("matrixDisplay").innerText = str;
}

// Expose functions
window.createCustomMesh = createCustomMesh;
window.applyTranslation = applyTranslation;
window.applyScaling = applyScaling;
window.applyRotationX = applyRotationX;
window.applyRotationY = applyRotationY;
window.applyRotationZ = applyRotationZ;
window.applyReflection = applyReflection;
window.applyShearing = applyShearing;
window.saveState = saveState;
window.undo = undo;
window.redo = redo;
window.resetMesh = resetMesh;

// Handle resize
window.addEventListener("resize", ()=>{
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
